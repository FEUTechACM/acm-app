import serverWrapper from "@/components/wrapper/serverWrapper";
import AdmZip from "adm-zip";
import { readFile } from "fs/promises";
import { NextResponse } from "next/server";
import { PDFDocument } from "pdf-lib";

export interface UndertakingBody {
	fullName: string;
	idImg: File | FileList;
	signatureImg: File | FileList;
	studentNumber: string;
	year: string;
	program: string;
	courses: string[];
}

const uniName = "FEU Institute of Technology";
const zip = new AdmZip();

const credits = `Generated by the ACM-X Undertaking Generator v0.1.0
Copyright FEU Tech ACM Student Chapter. All rights reserved.

Contributors (ACM App Team):

- Sir Abraham Magpantay   :  Adviser
- Jericho L. Menguito     :  President
- Cyril Reigine Paruli    :  Vice President
- Guennevere Rito         :  Project Manager/QA
- Alpha Romer Coma        :  Software Developer/Webmaster
- Emily Tan Sanchez       :  UI/UX Designer
- Francis Chuegan         :  UI/UX Designer

For further information, please contact us at <acm.feu.it@gmail.com>`;

const dataPath = "public/data";
const source = `${dataPath}/CONFIDENTIALITY-UNDERTAKING-template.pdf`;
const pageDims = {
	pageWidth: 612,
	pageHeight: 792,
};
const fontSize = {
	title: 7.8,
	reg: 10,
};
const sigMaxDims = {
	sigMaxWidth: 100,
	sigMaxHeight: 50,
};
const { title, reg } = fontSize;
const { pageWidth, pageHeight } = pageDims;
const { sigMaxWidth, sigMaxHeight } = sigMaxDims;

type UndertakingBodyWithoutIdSigCourse = Omit<
	UndertakingBody,
	"idImg" | "signatureImg" | "courses"
>;

const createTemplate = async (
	signatureBytes: Buffer,
	idBytes: Buffer,
	rest: UndertakingBodyWithoutIdSigCourse,
) => {
	const { fullName, year, program } = rest;
	const templatePdf = await PDFDocument.load(await readFile(source));
	const idImgPromise = templatePdf.embedJpg(idBytes);
	const sigImgPromise = templatePdf.embedPng(signatureBytes);
	const [idImg, sigImg] = await Promise.all([idImgPromise, sigImgPromise]);
	const aspectRatio = sigImg.width / sigImg.height;
	let sigWidth = sigMaxWidth;
	let sigHeight = sigMaxWidth / aspectRatio;

	if (sigHeight > sigMaxHeight) {
		sigHeight = sigMaxHeight;
		sigWidth = sigMaxHeight * aspectRatio;
	}

	const firstPage = templatePdf.getPage(0);
	firstPage.drawImage(sigImg, {
		x: 400,
		y: 145,
		width: sigWidth,
		height: sigHeight,
	});

	const date = new Date().toLocaleDateString("en-PH");
	firstPage.drawText(date, {
		x: 400,
		y: 96,
		size: reg,
	});

	firstPage.drawText(fullName, {
		x: 400,
		y: 136,
		size: reg,
	});

	firstPage.drawText(`${year} / ${program}`, {
		x: 400,
		y: 122,
		size: reg,
	});

	const { width: idWidth, height: idHeight } = idImg.scale(0.25);
	templatePdf.getPage(1).drawImage(idImg, {
		x: pageWidth / 2 - idWidth / 2,
		y: pageHeight / 2 - idHeight / 2,
		width: idWidth,
		height: idHeight,
	});

	return templatePdf.save();
};

const POST = serverWrapper(async (req) => {
	const formData = await req.formData();
	const body = Object.fromEntries(
		formData.entries(),
	) as unknown as UndertakingBody;
	const {
		fullName,
		studentNumber,
		year,
		program,
		courses,
		idImg,
		signatureImg,
	} = body;
	const coursesArray = JSON.parse(courses as any);

	const [signature, id] = await Promise.all([
		(signatureImg as File).arrayBuffer(),
		(idImg as File).arrayBuffer(),
	]);
	const idBytes = Buffer.from(id);
	const signatureBytes = Buffer.from(signature);

	const templatePdfBytes = await createTemplate(signatureBytes, idBytes, {
		fullName,
		year,
		program,
		studentNumber,
	});

	const promises = coursesArray.map(async (course: string) => {
		const pdfDoc = await PDFDocument.load(templatePdfBytes);
		const firstPage = pdfDoc.getPage(0);
		firstPage.drawText(`${uniName} - ${course}`, {
			x: 244,
			y: 694,
			size: title,
		});

		firstPage.drawText(studentNumber, {
			x: 400,
			y: 110,
			size: reg,
		});
		const coursePdfBytes = await pdfDoc.save();
		zip.addFile(
			`${course}-CONFIDENTIALITY-UNDERTAKING.pdf`,
			Buffer.from(coursePdfBytes),
		);
	});
	await Promise.allSettled(promises);
	const headers = new Headers();
	headers.append("Content-Disposition", "attachment; filename=archive.zip");
	headers.append("Content-Type", "application/zip");

	zip.addFile("README.md", Buffer.from(credits));
	const zipBuffer = zip.toBuffer();

	return new NextResponse(zipBuffer, {
		status: 200,
		headers,
	});
});

export { POST };
